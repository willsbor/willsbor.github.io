---
layout: post
title: Clean Architecture [3. 範式概述]
--- 

# 範式概述

## 三種範式

可以特別注意到等下描述的範式：

> 從程式設計師那邊移除了一些功能，並沒有增加什麼新的功能，是消極性的增加規範，告訴我們「不該」做什麼，而不是告訴我們「該」做什麼。

### 結構化程式設計 (structured programming)

使用為人所知的 if/then/else 和 go/while/until 來建構程式，取代 goto

> 結構化程式設計在直接的控制轉移上加上規範

### 物件導向程式設計 (object-orient programming)

從呼叫函式所設計的堆疊框架(stack frame)，移動到一個 heap 中。

該函式出為了累別的建構式 (constructor)

局部變數變成了實例變數 (instance variable)

內部巢狀函式變成了方法 (method)

透過有紀律的使用函式指標，就必然會發現多型 (polymorphism)

> 物件導向程式設計在間接地控制轉移上加上規範

### 函數式程式設計 (functional programming)

從 l-calculus 出發，成為 LISP 語言的基礎。l-calculus 的基礎概念是不變性 (immutability)，也就是說，符號的值不會改變。而函數式語言大部分都有一些方法可以改變變數值，但只能在嚴格的條件下

> 函數式程式設計在賦值上加上規範


## 總結

`範式的歷史與架構是所有的一切`

多型跨越架構邊界的機制，規範函數式程設設計對資料存取，結構化程式設計是模組的演算法基礎

```
重新知道一直以來使用程式設計範式的歷史和初衷，感覺真的很有趣，一直以來我們都是被剝奪了許多的能力（哭）。但是有紀律的使用程式語言，最終目標應該是要面對「穩定與變動」:

在能「變動」擴充原有的功能下，且能保持原有功能的「穩定」。

加上了規範，更能確保變動是可預期的。到後來用到的 protocol / abstract interface 大致上也有同樣的意圖。定義好規範，實作的「變動」則由程式設計師來填入。
```

第二章： [兩種價值觀的故事](2018-09-05-CleanArchitecture-3.md)

第四章： [結構化程式設計](2018-10-04-CleanArchitecture-5.md)
